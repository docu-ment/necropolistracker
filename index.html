<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Necropolis Tracker</title>
    <script type="module" src="https://www.gstatic.com/firebasejs/11.0.1/firebase-app.js"></script>
    <script type="module" src="https://www.gstatic.com/firebasejs/11.0.1/firebase-database.js"></script>
    <script type="module" src="https://www.gstatic.com/firebasejs/11.0.1/firebase-firestore.js"></script>
    <script src="cookies.js" defer></script>
    
    <style>
        /* Basic reset for a dark theme */
        body {
            background-color: #121212; /* Dark background */
            color: white; /* Light text */
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 50;
        }
    
        h1, h2 {
            color: #e0e0e0; /* Lighter text for headers */
        }
    


        .highlight {
    background-color: yellow; /* Change to any color you like */
    font-weight: bold;
}


        .container {
            padding: 10px;
        }
    
        .form-row {
            margin-bottom: 15px;
        }
    
        .notification-status {
            margin-left: 10px;
            font-style: italic;
            color: #ccc; /* Light gray color for status text */
        }
    
        .voted-map-entry {
            margin: 10px 0;
            background-color: #333; /* Dark background for map entries */
            padding: 10px;
            border-radius: 5px;
            width: 50%; /* Reduced width for voted map entries */
            text-align: center;
        }
    
           
        .timer {
            font-weight: bold;
            margin-left: 10px;
            color: #ffff00; /* Yellow for the timer, more accessible */
        }
    
        .vote-buttons {
            display: inline-block;
            margin-left: 15px;
        }
    
        .vote-count {
            margin-left: 5px;
        }
    
        #mapSuggestions {
            list-style-type: none;
            padding: 0;
            margin: 0;
            border: 1px solid #444; /* Dark border */
            max-height: 250px;
            overflow-y: auto;
            position: absolute; /* Ensure suggestions are positioned correctly */
            z-index: 2000; /* Make sure suggestions appear above other content */
            background-color: #222; /* Dark background for suggestions */
        }
    
        #mapSuggestions li {
            padding: 11px;
            cursor: pointer;
            color: white; /* White text for suggestions */
        }
    
        #mapSuggestions li:hover {
            background-color: #444; /* Dark hover effect */
        }
    
        .voted-maps-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    color: #e0e0e0;
}
    
        label {
            color: #ccc; /* Light gray color for labels */
        }
    
        button {
            background-color: #444; /* Dark button background */
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
        }
    
        button:hover {
            background-color: #666; /* Lighter background on hover */
        }
    
        input[type="text"], input[type="number"], input[type="range"] {
            background-color: #333; /* Dark input background */
            color: white; /* White text for input */
            border: 1px solid #555; /* Slightly lighter border */
            padding: 5px;
            border-radius: 1px;
        }
    
        input[type="text"]:focus, input[type="number"]:focus, input[type="range"]:focus {
            border-color: #888; /* Highlight border color when focused */
        }
    
        /* For the notification volume range */
        #volumeValue {
            color: #ccc;
        }
    
        .form-row label {
            margin-right: 0px;
        }

        .cookie-banner {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    background-color: #333;
    color: white;
    padding: 20px;
    text-align: center;
    z-index: 1000;
}

.cookie-banner button {
    background-color: #4CAF50;
    color: white;
    padding: 10px 20px;
    border: none;
    cursor: pointer;
}

.cookie-banner button:hover {
    background-color: #45a049;
}

.privacy-link {
    color: #4CAF50;
    text-decoration: underline;
    margin-left: 10px;
}

.privacy-link:hover {
    color: #45a049;
}




    </style>
    
    <body>
        <section>

      <!-- Cookie Consent Banner -->
<div id="cookies-banner" style="display: none;">
    <p>This website uses cookies to ensure you get the best experience on our website. 
       <button id="accept-all-cookies">Accept All Cookies</button>
       <button id="accept-essential-cookies">Accept Essential Cookies</button>
    </p>
</div>



            
            <h1>Necropolis Tracker: Settlers of Kalguur</h1>
            <h2>Notification Settings</h2>
            <p>Select mod to be notified about:</p>
            <form id="notificationForm">
                <div class="form-row">
                    <label><input type="checkbox" value="exp" id="expCheckbox"> Exp</label>
                    <label><input type="checkbox" value="divine orbs" id="divineOrbsCheckbox"> Divine Orbs</label>
                    <label><input type="checkbox" value="quantity" id="quantityCheckbox"> Quantity</label>
                    <label><input type="checkbox" value="quantity of strongest" id="quantityStrongestCheckbox"> Quantity of Strongest</label>
                    <label><input type="checkbox" value="possessed" id="possessedCheckbox"> Possessed</label>
                    <label><input type="checkbox" value="convert to magic packs" id="convertMagicPacksCheckbox"> Convert to Magic Packs</label>
                    <label><input type="checkbox" value="packsize" id="packsizeCheckbox"> Packsize</label>
                    <label><input type="checkbox" value="rarity" id="rarityCheckbox"> Rarity</label>
                    <label><input type="checkbox" value="rarity of strongest" id="rarityStrongestCheckbox"> Rarity of Strongest</label>
                    <label><input type="checkbox" value="exalted orb" id="exaltedOrbCheckbox"> Exalted Orb</label>
                    <label><input type="checkbox" value="annulment orb" id="annulmentOrbCheckbox"> Annulment Orb</label>
                    <label><input type="checkbox" value="chaos orb" id="chaosOrbCheckbox"> Chaos Orb</label>
                    <label><input type="checkbox" value="regal orb" id="regalOrbCheckbox"> Regal Orb</label>
                </div>
    
                <div class="form-row">
                    <label for="upvoteThreshold">Upvotes required for notification:</label>
                    <input type="number" id="upvoteThreshold" min="0" value="1" step="1">
                    <label for="volumeControl"> Volume: <span id="volumeValue">50%</span></label>
                    <input type="range" id="volumeControl" min="0" max="100" value="50" step="10" oninput="updateVolume()">
                </div>
                <label>
                    <input type="checkbox" id="enable-notifications" />
                    Enable Browser Notifications
                </label>

                <button type="button" onclick="setNotifications()">Set Notifications</button>
            <span id="notificationStatus" class="notification-status">Currently no notification saved.</span>
        </form>
        </section>
    
        <section>
            <h2 class="voted-maps-header">
                <div>
                    <span>Voted Maps</span>
                    <span id="timer" class="timer">1:19</span>
                </div>
            </h2>
    
            <div id="votedMaps">
                <ul id="votedMapsList"></ul>
            </div>
        </section>
    
        <section>
            <h2>Select Map and Modifiers</h2>
            <form id="modForm">
                <p>Select Modifiers:</p>
                <label><input type="checkbox" name="mod" value="exp"> Exp</label>
                <label><input type="checkbox" name="mod" value="divine orbs"> Divine Orbs</label>
                <label><input type="checkbox" name="mod" value="quantity"> Quantity</label>
                <label><input type="checkbox" name="mod" value="quantity of strongest"> Quantity of Strongest</label>
                <label><input type="checkbox" name="mod" value="possessed"> Possessed</label>
                <label><input type="checkbox" name="mod" value="convert to magic packs"> Convert to Magic Packs</label>
                <label><input type="checkbox" name="mod" value="packsize"> Packsize</label>
                <label><input type="checkbox" name="mod" value="rarity"> Rarity</label>
                <label><input type="checkbox" name="mod" value="rarity of strongest"> Rarity of Strongest</label>
                <label><input type="checkbox" name="mod" value="exalted orb"> Exalted Orb</label>
                <label><input type="checkbox" name="mod" value="annulment orb"> Annulment Orb</label>
                <label><input type="checkbox" name="mod" value="chaos orb"> Chaos Orb</label>
                <label><input type="checkbox" name="mod" value="regal orb"> Regal Orb</label>
    
                <div>
                    <input type="text" id="mapInput" placeholder="Enter map name" />
                </div>
                <ul id="mapSuggestions"></ul>
    
                <button type="button" onclick="submitVote()">Confirm</button>
            </form>
        </section>

      
        <audio id="notificationSound" src="audio.mp3" preload="auto"></audio>

    <script type="module">
        // Import Firebase functions
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-app.js";
        import { getFirestore, collection, addDoc, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-firestore.js"; 
        import { getDatabase, ref, onValue, set, get } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-database.js";
        
        // Initialize Firebase
        const firebaseConfig = {
            apiKey: "AIzaSyAp8H_Lcu1ySmbmAUEwRPSkwHbUBWHSx2Y",
            authDomain: "necropolistracker.firebaseapp.com",
            databaseURL: "https://necropolistracker-default-rtdb.europe-west1.firebasedatabase.app/",
            projectId: "necropolistracker",
            storageBucket: "necropolistracker.appspot.com",
            messagingSenderId: "327513254673",
            appId: "1:327513254673:web:00a4feff1acc6fe9be7ab0",
            measurementId: "G-5FQKZ5M6KC"
        };

        const app = initializeApp(firebaseConfig);
        const database = getDatabase();
        const db = getFirestore(app);
        let votedMaps = {};
        let userVotes = {};
        let notificationSettings = {
            mods: [], // Array of selected mods
            upvoteThreshold: 1,
            volume: 50
        };
        


        
        const maps = [
            "Olmec's Sanctum", "Gardens Map", "Siege Map", "Bone Crypt Map", "Scriptorium Map", "Pillars of Arun",
            "Dark Forest Map", "Lair Map", "Dunes Map", "Tropical Island Map", "Lava Lake Map", "Dungeon Map",
            "Carcass Map", "Flooded Mine Map", "Whakawairua Tuahu", "Acton's Nightmare", "Dry Sea Map", "Strand Map",
            "Marshes Map", "Bog Map", "Fungal Hollow Map", "Cage Map", "Armoury Map", "Overgrown Shrine Map",
            "Vaults of Atziri", "Hallowed Ground", "The Twilight Temple", "Mesa Map", "Cemetery Map", "Cells Map",
            "Vaal Pyramid Map", "Vault Map", "Relic Chambers Map", "Mausoleum Map", "Moon Temple Map",
            "MaelstrÃ¶m of Chaos", "The Vinktar Square", "Courtyard Map", "Colonnade Map", "Summit Map",
            "Ancient City Map", "Atoll Map", "Plateau Map", "Fields Map", "Graveyard Map", "Mao Kun",
            "Colosseum Map", "Castle Ruins Map", "Shore Map", "Promenade Map", "Belfry Map", "Estuary Map",
            "Defiled Cathedral Map", "The Coward's Trial", "Spider Forest Map", "Forbidden Woods Map",
            "Bramble Valley Map", "Racecourse Map", "Channel Map", "Cursed Crypt Map", "Chateau Map",
            "Desert Map", "Jungle Valley Map", "City Square Map", "Cold River Map", "Ramparts Map", "Silo Map",
            "Arachnid Tomb Map", "Coral Ruins Map", "Haunted Mansion Map", "Spider Lair Map", "Toxic Sewer Map",
            "Basilica Map", "Palace Map", "Dig Map", "Sulphur Vents Map", "Burial Chambers Map", "Malformation Map",
            "Leyline Map", "Underground Sea Map", "Crimson Township Map", "Port Map", "Crater Map", "Pier Map",
            "Grotto Map", "Foundry Map", "The Putrid Cloister", "Death and Taxes", "Geode Map", "Infested Valley Map",
            "Lookout Map", "Courthouse Map", "Necropolis Map", "Museum Map", "Arcade Map", "Ashen Wood Map",
            "Desert Spring Map", "Glacier Map", "Caldera Map", "Doryani's Machinarium", "Poorjoy's Asylum",
            "Beach Map", "Coves Map", "Maze Map", "Residence Map", "Temple Map", "Caer Blaidd, Wolfpack's Den",
            "Pit Map", "Alleyways Map", "Terrace Map", "Underground River Map", "Academy Map", "Orchard Map",
            "Lighthouse Map", "Pit of the Chimera Map", "Crystal Ore Map", "Sepulchre Map", "Vaal Temple Map",
            "Lair of the Hydra Map", "Maze of the Minotaur Map", "Forge of the Phoenix Map", "Abomination Map",
            "Citadel Map", "Fortress Map", "Ziggurat Map", "Sanctuary Map"
        ];
        
        function loadVotesFromFirebase() {
            const votesRef = ref(database, 'votes');
            onValue(votesRef, (snapshot) => {
                votedMaps = snapshot.val() || {};
                displayVotedMaps();
            });
        }

        function confirmVote(mapInput, modifiers) {
    const voteData = {
        modifiers: modifiers // Assuming modifiers is an array
    };

    const votedMapsRef = firebase.database().ref(`votes/${mapInput}`);
    votedMapsRef.set(voteData, (error) => {
        if (error) {
            console.error('Error uploading data:', error);
        } else {
            console.log('Vote confirmed for', mapInput);
            displayVotedMaps(); // Refresh the list after confirming
        }
    });
}

function displayVotedMaps() {
        const votedMapsList = document.getElementById('votedMapsList');
        votedMapsList.innerHTML = ''; // Clear existing list

        for (const mapName in votedMaps) {
            if (votedMaps.hasOwnProperty(mapName)) {
                const mapData = votedMaps[mapName];
                const modifiersList = mapData.modifiers.join(', '); // Join modifiers into a string
                const votesCount = mapData.votes || 0; // Get the vote count

                // Create a list item with the desired format
                const listItem = document.createElement('li');
                listItem.className = 'voted-map-entry'; // Add a class for styling
                listItem.textContent = `${mapName} | Modifiers: [${modifiersList}] | Votes: ${votesCount}  `;

                // Create upvote and downvote buttons
                const upvoteButton = document.createElement('button');
                upvoteButton.textContent = 'Upvote ';
                upvoteButton.onclick = () => updateVote(mapName, mapData.modifiers, 1); // Upvote logic

                const downvoteButton = document.createElement('button');
                downvoteButton.textContent =  ' Downvote';
                downvoteButton.onclick = () => updateVote(mapName, mapData.modifiers, -1); // Downvote logic

                // Append buttons to list item
                listItem.appendChild(upvoteButton);
                listItem.appendChild(downvoteButton);
                votedMapsList.appendChild(listItem);
            }
        }
    }

// Function to update the vote count (called when a user upvotes/downvotes)
function updateVote(mapId, modifiers, voteType) {
    // Check if the user has already voted on this map
    if (userVotes[mapId] !== undefined) {
        alert('You have already voted for this map.');
        return; // Prevent further voting on the same map
    }

    const votesRef = ref(database, 'votes/' + mapId); // Reference to the votes in the database

    // Use the get method to read the votes once
    get(votesRef).then((snapshot) => {
        let currentVotes = snapshot.val() || { votes: 0, downvotes: 0 }; // Default structure for votes and downvotes

        // Update votes count based on vote type
        if (voteType === 1) { // Upvote
            currentVotes.votes = (currentVotes.votes || 0) + 1;

           

        } else if (voteType === -1) { // Downvote
            currentVotes.votes = (currentVotes.votes || 0) - 1;
            currentVotes.downvotes = (currentVotes.downvotes || 0) + 1;
        }

        // Check if the map should be deleted due to too many downvotes
        if (currentVotes.downvotes >= 4) {  // You can adjust the threshold (e.g., 3 downvotes)
            deleteMap(mapId); // Call the delete function to remove the map
        } else {
            // Update the database with the new votes count
            set(votesRef, currentVotes)
                .then(() => {
                    console.log(`Votes updated for ${mapId}: ${currentVotes.votes}`);
                    checkNotifications(mapId); 
                    userVotes[mapId] = voteType; // Mark this map as voted
                    loadVotesFromFirebase(); // Refresh the display
                })
                .catch((error) => {
                    console.error("Error updating votes:", error);
                });
        }
    }).catch((error) => {
        console.error("Error reading votes:", error);
    });
}

 // Function to delete a map from the database (if too many downvotes)
 function deleteMap(mapId) {
            const mapRef = ref(database, 'votes/' + mapId);
            set(mapRef, null).then(() => {
                console.log(`Map ${mapId} deleted due to too many downvotes.`);
                loadVotesFromFirebase(); // Refresh the display
            }).catch((error) => {
                console.error("Error deleting map:", error);
            });
        }



        function checkNotifications(mapName) {
    const mapVotes = votedMaps[mapName];
    const upvotes = mapVotes?.votes || 0;
    const selectedModifiers = [...document.querySelectorAll('input[type="checkbox"]:checked')].map(cb => cb.value);

    // Check if the map matches the selected modifiers and upvote threshold
    const modifierMatch = selectedModifiers.every(mod => mapVotes.modifiers.includes(mod));

    if (upvotes >= notificationSettings.upvoteThreshold && modifierMatch) {
        // Trigger notification sound
        const sound = document.getElementById('notificationSound');
        sound.volume = notificationSettings.volume / 100;  // Adjust volume
        sound.play();

        // Update the browser tab title with the number of votes for this map
        updateTabTitle(mapName, upvotes);
    }
}

function updateTabTitle(mapName, upvotes) {
    // Retrieve or initialize a counter for this map
    if (!window.voteCounters) window.voteCounters = {};

    // Initialize or increment the counter for the map
    if (!window.voteCounters[mapName]) {
        window.voteCounters[mapName] = 0;
    }
    window.voteCounters[mapName]++;

    // Format the tab title with the vote count in parentheses
    const voteCount = window.voteCounters[mapName];
    document.title = `(${voteCount}) ${mapName} - Map Tracker`;

    // Optionally, reset the tab title back to normal if no votes are left
    setTimeout(() => {
        if (window.voteCounters[mapName] === voteCount) {
            document.title = 'Map Tracker';  // Reset after a short delay, or keep it as is
        }
    }, 10000); // Reset after 10 seconds or choose any duration
}


        function setNotifications() {
    // Get the selected mods from the checkboxes
    const selectedMods = Array.from(document.querySelectorAll('input[type=checkbox]:checked')).map(cb => cb.value);
    
    // Get the upvote threshold and volume settings
    const upvoteThreshold = document.getElementById('upvoteThreshold').value;
    const volume = document.getElementById('volumeControl').value;
    
    // Store the settings in notificationSettings
    notificationSettings.mods = selectedMods;
    notificationSettings.upvoteThreshold = upvoteThreshold;
    notificationSettings.volume = volume;
    
    // Display notification settings status
    notificationStatus.textContent = `Notifications set for mods: ${selectedMods.join(', ')} with threshold: ${upvoteThreshold} at volume: ${volume}%`;
    
    // Check existing voted maps to see if any match the notification criteria
    for (const map in votedMaps) {
        const mapVotes = votedMaps[map];
        const upvotes = mapVotes?.votes || 0;
        const mapModifiers = mapVotes?.modifiers || [];
        
        // Check if the map meets the selected modifiers and upvote threshold
        const modifierMatch = selectedMods.every(mod => mapModifiers.includes(mod));
        if (upvotes >= upvoteThreshold && modifierMatch) {
            // Trigger the notification
            const sound = document.getElementById('notificationSound');
            sound.volume = volume / 100;  // Adjust the volume
            sound.play();
            alert(`Notification! ${map} has reached ${upvotes} upvotes with modifiers: ${mapModifiers.join(', ')}`);
        }
    }
}



        

        function updateVolume() {
            const volumeControl = document.getElementById('volumeControl');
            const volumeValue = document.getElementById('volumeValue');
            volumeValue.innerText = volumeControl.value + "%";
            const sound = document.getElementById('notificationSound');
            sound.volume = volumeControl.value / 100;
        }

        function submitVote() {
    const mapInput = document.getElementById('mapInput').value.trim();
    const modifiers = Array.from(document.querySelectorAll('input[name="mod"]:checked')).map(input => input.value);

    // Check if the map is valid before submitting
    if (!maps.includes(mapInput)) {
        alert('Please select a valid map from the suggestions or enter a correct map name.');
        return;
    }

    if (!modifiers.length) {
        alert('Please select at least one modifier.');
        return;
    }

    // Check if the user has already voted
    if (userVotes[mapInput] !== undefined) {
        alert('You have already voted for this map.');
        return; // Prevent further voting on the same map
    }

    // This sets the vote and updates the database
    const votesRef = ref(database, 'votes/' + mapInput);
    set(votesRef, {
        modifiers: modifiers,
        votes: (votedMaps[mapInput]?.votes || 0) + 1,
        timestamp: serverTimestamp()
    })
    .then(() => {
        console.log(`Vote submitted for ${mapInput}: ${modifiers}`);
        userVotes[mapInput] = 1; // Mark this map as voted
        alert(`Thank you for voting for ${mapInput}!`);
        displayVotedMaps(); // Ensure the list updates immediately after submitting a vote
    })
    .catch((error) => {
        console.error('Error submitting vote:', error);
        alert('Failed to submit vote. Please try again later.');
    });

    document.getElementById('mapInput').value = '';
    document.getElementById('mapSuggestions').innerHTML = ''; // Clear suggestions after vote
    displayVotedMaps();
}

        function searchMap() {
            const input = document.getElementById('mapInput').value.toLowerCase();
            const suggestions = maps.filter(map => map.toLowerCase().includes(input));
            displayMapSuggestions(suggestions);
        }

        function displayMapSuggestions(suggestions) {
            const suggestionsList = document.getElementById('mapSuggestions');
            suggestionsList.innerHTML = "";
            suggestions.forEach(map => {
                const listItem = document.createElement("li");
                listItem.textContent = map;
                listItem.onclick = () => {
                    document.getElementById('mapInput').value = map;
                    suggestionsList.innerHTML = "";
                };
                suggestionsList.appendChild(listItem);
            });
        }

        document.getElementById('mapInput').addEventListener('input', searchMap);
        
        function startTimer() {
    const timerDisplay = document.getElementById('timer');

    // Calculate the time remaining until the next full hour
    function getNextHour() {
        const now = new Date();
        return new Date(now.getFullYear(), now.getMonth(), now.getDate(), now.getHours() + 1, 0, 0).getTime();
    }

    let nextResetTime = getNextHour();

    function updateTimer() {
        const now = Date.now();
        const timeRemaining = nextResetTime - now;

        // Calculate minutes and seconds left
        const minutes = Math.floor(timeRemaining / 60000);
        const seconds = Math.floor((timeRemaining % 60000) / 1000);

        // Update the timer display
        timerDisplay.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;

        if (timeRemaining <= 0) {
            resetVotes(); // Reset votes when countdown reaches 0
            nextResetTime = getNextHour(); // Set next reset time to the following full hour
        }
    }

    // Clear any existing interval to prevent overlaps
    if (window.countdownInterval) clearInterval(window.countdownInterval);

    // Start a new countdown interval
    window.countdownInterval = setInterval(updateTimer, 1000); // Update every second
    updateTimer(); // Initial call to set display immediately
}

        function resetVotes() {
            const votesRef = ref(database, 'votes');
            set(votesRef, {}); // Reset all votes
            alert("All votes have been reset.");
        }

        // Load existing votes from Firebase on page load
        window.onload = function() {
            loadVotesFromFirebase();
            startTimer();
        };


// Check if notifications are already granted or denied
function checkNotificationPermission() {
    if (Notification.permission === 'granted') {
        // Notifications are already enabled
        console.log('Notifications are enabled');
    } else if (Notification.permission === 'denied') {
        // Notifications are disabled
        console.log('Notifications are denied');
    } else {
        // Ask for permission to show notifications
        requestNotificationPermission();
    }
}

// Request notification permission from the user
function requestNotificationPermission() {
    Notification.requestPermission().then(permission => {
        if (permission === 'granted') {
            console.log('Notification permission granted');
            // Optionally, trigger the first notification here
        } else {
            console.log('Notification permission denied');
        }
    });
}

// Handle showing notifications even when the tab is in the background
function showBackgroundNotification() {
    if (Notification.permission === 'granted') {
        const notification = new Notification('You have a new update!', {
            body: 'Check out the latest content!',
            icon: '/path/to/icon.png'
        });

        // Optionally, you can add event listeners for notification actions
        notification.onclick = function () {
            window.open('https://yourwebsite.com');
        };
    }
}


        document.addEventListener('DOMContentLoaded', () => {
            loadVotesFromFirebase();
            startTimer();
            checkNotificationPermission();
            
    
            // Expose functions to the global scope
            window.setNotifications = setNotifications;
            window.submitVote = submitVote;
            window.updateVolume = updateVolume;
    
            const mapInput = document.getElementById('mapInput');
            mapInput.addEventListener('input', () => {
                const suggestions = maps.filter(map => map.toLowerCase().includes(mapInput.value.toLowerCase()));
                const mapSuggestions = document.getElementById('mapSuggestions');
                mapSuggestions.innerHTML = ''; // Clear previous suggestions

                // Display suggestions
                suggestions.forEach(map => {
                    const li = document.createElement('li');
                    li.textContent = map;
                    li.onclick = () => {
                        mapInput.value = map; // Set input value to selected suggestion
                        mapSuggestions.innerHTML = ''; // Clear suggestions
                    };
                    mapSuggestions.appendChild(li);
                });
            });
        });

    </script>
</body>
</html>
